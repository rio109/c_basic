### INTERGER



# C 언어 자료형 정리

## 정수형

| 자료형            | 설명                                        | 비트 수    | 값의 범위                                     | 포맷 지정자 |
|-------------------|---------------------------------------------|------------|-----------------------------------------------|-------------|
| `char`            | 문자형 데이터, 기본적으로 1바이트          | 8 비트     | -128 ~ 127 (signed), 0 ~ 255 (unsigned)      | `%c`        |
| `short`           | 짧은 정수형 데이터, 기본적으로 2바이트     | 16 비트    | -32,768 ~ 32,767 (signed), 0 ~ 65,535 (unsigned) | `%d`        |
| `int`             | 기본 정수형 데이터, 보통 4바이트            | 32 비트    | -2,147,483,648 ~ 2,147,483,647 (signed), 0 ~ 4,294,967,295 (unsigned) | `%d`        |
| `long`            | 긴 정수형 데이터, 보통 4바이트 또는 8바이트 | 32 또는 64 비트 | -2,147,483,648 ~ 2,147,483,647 (signed, 32 비트), -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 (signed, 64 비트) | `%ld`       |
| `long long`       | 매우 긴 정수형 데이터, 보통 8바이트         | 64 비트    | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 (signed), 0 ~ 18,446,744,073,709,551,615 (unsigned) | `%lld`      |
| `unsigned char`   | 부호 없는 문자형 데이터, 1바이트            | 8 비트     | 0 ~ 255 (unsigned)                            | `%c`        |
| `unsigned short`  | 부호 없는 짧은 정수형 데이터, 2바이트      | 16 비트    | 0 ~ 65,535 (unsigned)                         | `%u`        |
| `unsigned int`    | 부호 없는 기본 정수형 데이터, 4바이트       | 32 비트    | 0 ~ 4,294,967,295 (unsigned)                 | `%u`        |
| `unsigned long`   | 부호 없는 긴 정수형 데이터, 4바이트 또는 8바이트 | 32 또는 64 비트 | 0 ~ 4,294,967,295 (unsigned, 32 비트), 0 ~ 18,446,744,073,709,551,615 (unsigned, 64 비트) | `%lu`       |
| `unsigned long long` | 부호 없는 매우 긴 정수형 데이터, 8바이트 | 64 비트    | 0 ~ 18,446,744,073,709,551,615 (unsigned)   | `%llu`      |

## 실수형

| 자료형           | 설명                                         | 비트 수    | 값의 범위                                       | 포맷 지정자 |
|------------------|----------------------------------------------|------------|-------------------------------------------------|-------------|
| `float`          | 단정도 실수형 데이터, 보통 4바이트           | 32 비트    | 약 ±3.4 × 10^38 (정밀도 6-7자리)                | `%f`        |
| `double`         | 배정도 실수형 데이터, 보통 8바이트           | 64 비트    | 약 ±1.7 × 10^308 (정밀도 15-16자리)             | `%lf`       |
| `long double`    | 확장 배정도 실수형 데이터, 보통 12 또는 16바이트 | 80 또는 128 비트 | 약 ±1.1 × 10^4932 (정밀도 18-19자리, 시스템에 따라 다름) | `%Lf`       |

## 문자형

| 자료형       | 설명                               | 비트 수 | 값의 범위                          | 포맷 지정자 |
|--------------|------------------------------------|---------|------------------------------------|-------------|
| `char`       | 기본 문자형 데이터, 1바이트        | 8 비트  | -128 ~ 127 (signed), 0 ~ 255 (unsigned) | `%c`        |

## 불리언형

| 자료형       | 설명                                   | 비트 수 | 값의 범위     | 포맷 지정자 |
|--------------|----------------------------------------|---------|---------------|-------------|
| `_Bool`      | 불리언형 데이터 (C99 표준 이후)       | 1 비트  | 0 (false) 또는 1 (true) | `%d` (0 또는 1로 출력) |

## 문자열

- **문자열**은 C 언어에서 문자열 상수로 표현됩니다. `char` 배열을 사용하여 문자열을 저장합니다.
  
  예:
  ```c
  char str[] = "Hello, World!";

```c
#include <stdio.h>

int main() {
    // char 자료형
    char c = 'A';  // 문자형 변수 선언 및 초기화
    printf("char: %c\n", c);  // 문자형 변수 출력

    // short 자료형
    short s = 32767;  // 짧은 정수형 변수 선언 및 초기화
    printf("short: %d\n", s);  // 짧은 정수형 변수 출력

    // int 자료형
    int i = 2147483647;  // 기본 정수형 변수 선언 및 초기화
    printf("int: %d\n", i);  // 기본 정수형 변수 출력

    // long 자료형
    long l = 2147483648L;  // 긴 정수형 변수 선언 및 초기화 (4바이트 또는 8바이트 시스템에 따라 다름)
    printf("long: %ld\n", l);  // 긴 정수형 변수 출력

    // long long 자료형
    long long ll = 9223372036854775807LL;  // 매우 긴 정수형 변수 선언 및 초기화
    printf("long long: %lld\n", ll);  // 매우 긴 정수형 변수 출력

    // unsigned 자료형
    unsigned int ui = 4294967295U;  // 부호 없는 기본 정수형 변수 선언 및 초기화
    printf("unsigned int: %u\n", ui);  // 부호 없는 기본 정수형 변수 출력

    // float 자료형
    float f = 3.14f;  // 단정도 실수형 변수 선언 및 초기화
    printf("float: %f\n", f);  // 단정도 실수형 변수 출력

    // double 자료형
    double d = 3.141592653589793;  // 배정도 실수형 변수 선언 및 초기화
    printf("double: %lf\n", d);  // 배정도 실수형 변수 출력

    // long double 자료형
    long double ld = 3.141592653589793238L;  // 확장 배정도 실수형 변수 선언 및 초기화
    printf("long double: %Lf\n", ld);  // 확장 배정도 실수형 변수 출력

    // _Bool 자료형 (C99 이후)
    _Bool b = 1;  // 불리언형 변수 선언 및 초기화 (true)
    printf("_Bool: %d\n", b);  // 불리언형 변수 출력 (0 또는 1)

    // 문자열
    char str[] = "Hello, World!";  // 문자열 변수 선언 및 초기화
    printf("string: %s\n", str);  // 문자열 출력

    return 0;
}

```


# 재귀 함수 vs 반복문

| 측면              | 재귀 함수 (Recursive Function)                           | 반복문 (Iteration)                              |
|-------------------|-----------------------------------------------------------|--------------------------------------------------|
| **정의**          | 함수가 자기 자신을 호출하여 문제를 해결합니다.            | 동일한 코드 블록을 반복적으로 실행합니다.      |
| **메모리 사용**   | 각 호출마다 새로운 스택 프레임을 생성하여 메모리 사용이 많습니다. 깊은 재귀로 인해 스택 오버플로우가 발생할 수 있습니다. | 단일 루프 블록에서 실행되므로 메모리 사용이 상대적으로 효율적입니다. |
| **변수 관리**     | 각 호출마다 독립적인 변수 상태를 가지므로, 변수 값이 호출마다 새롭게 저장됩니다. | 반복문 내에서 동일한 변수를 사용하며, 값이 계속 업데이트됩니다. |
| **종료 조건**     | 적절한 종료 조건이 필요하며, 종료 조건이 없거나 잘못 설정되면 무한 재귀가 발생할 수 있습니다. | 종료 조건은 루프의 조건에 의해 제어되며, 잘못된 조건으로 무한 루프가 발생할 수 있습니다. |
| **코드 복잡성**   | 문제를 자연스럽게 표현할 수 있는 경우가 많지만, 이해하기 어려울 수 있습니다. | 코드가 명확하고 이해하기 쉬운 경우가 많습니다. |
| **디버깅**        | 재귀 호출이 많아지면 디버깅이 어려울 수 있으며, 스택 트레이스를 추적하기 복잡할 수 있습니다. | 반복문 내의 변수 상태를 추적하기 쉬우며, 디버깅이 상대적으로 간단합니다. |
| **성능**          | 함수 호출이 많아 성능이 저하될 수 있으며, 메모리 사용이 비효율적일 수 있습니다. | 반복문은 함수 호출이 없으므로 성능이 상대적으로 우수하며, 메모리 사용이 효율적입니다. |
| **문제 해결**     | 재귀는 복잡한 문제를 더 자연스럽고 간결하게 표현할 수 있는 경우가 많습니다. | 반복문은 간단하고 반복적인 작업에 적합합니다. |

